
# Operator

## id      :  ->
Identity function, does nothing.
Any program of the form  `P id Q`  is equivalent to just  `P Q`.

## dup      :   `X`  ->   `X X`
Pushes an extra copy of `X` onto stack.

## swap      :   `X Y`  ->   `Y X`
Interchanges `X` and `Y` on top of the stack.

## rollup      :  `X Y Z`  ->  `Z X Y`
Moves `X` and `Y` up, moves `Z` down

## rolldown      :  `X Y Z`  ->  `Y Z X`
Moves `Y` and `Z` down, moves `X` up

## rotate      :  `X Y Z`  ->  `Z Y X`
Interchanges `X` and `Z`

## popd      :  `Y Z`  ->  `Z`
As if defined by:   `popd  ==  [pop] dip` 

## dupd      :  `Y Z`  ->  `Y Y Z`
As if defined by:   `dupd  ==  [dup] dip`

## swapd      :  `X Y Z`  ->  `Y X Z`
As if defined by:   `swapd  ==  [swap] dip`

## rollupd      :  `X Y Z W`  ->  `Z X Y W`
As if defined by:   `rollupd  ==  [rollup] dip`

## rolldownd      :  `X Y Z W`  ->  `Y Z X W`
As if defined by:   `rolldownd  ==  [rolldown] dip` 

## rotated      :  `X Y Z W`  ->  `Z Y X W`
As if defined by:   `rotated  ==  [rotate] dip`

## pop      :   `X`  ->
Removes `X` from top of the stack.

## choice      :  `B T F`  ->  `X`
If `B` is true, then `X = T` else `X = F`.

## or      :  `X Y`  ->  `Z`
`Z` is the union of sets `X` and `Y`, logical disjunction for truth values.

## xor      :  `X Y`  ->  `Z`
`Z` is the symmetric difference of sets `X` and `Y`,
logical exclusive disjunction for truth values.

## and      :  `X Y`  ->  `Z`
`Z` is the intersection of sets `X` and `Y`, logical conjunction for truth values.

## not      :  `X`  ->  `Y`
`Y` is the complement of set `X`, logical negation for truth values.

## trunc      :  `F`  ->  `I`
`I` is an integer equal to the float `F` truncated toward zero.

## localtime      :  `I`  ->  `T`
Converts a time `I` into a list `T` representing local time:
`[year month day hour minute second isdst yearday weekday]`.
Month is 1 = January ... 12 = December;
isdst is a Boolean flagging daylight savings/summer time;
weekday is 0 = Monday ... 7 = Sunday.

## gmtime      :  `I`  ->  `T`
Converts a time `I` into a list `T` representing universal time:
`[year month day hour minute second isdst yearday weekday]`.
Month is 1 = January ... 12 = December;
isdst is false; weekday is 0 = Monday ... 7 = Sunday.

## mktime      :  `T`  ->  `I`
Converts a list `T` representing local time into a time `I`.
`T` is in the format generated by localtime.

## strftime      :  `T S1`  ->  `S2`
Formats a list `T` in the format of localtime or gmtime
using string `S1` and pushes the result `S2`.

## strtol      :  `S I`  ->  `J`
String `S` is converted to the integer `J` using base `I`.
If `I = 0`, assumes base `10`,
but leading `"0"` means base 8 and leading `"0x"` means base 16.

## strtod      :  `S`  ->  `R`
String `S` is converted to the float `R`.

## format      :  `N C I J`  ->  `S`
`S` is the formatted version of `N` in mode `C`
(`'d` or `'i` = decimal, `'o` = octal, `'x` or
`'X` = hex with lower or upper case letters)
with maximum width `I` and minimum width `J`.

## formatf      :  `F C I J`  ->  `S`
`S` is the formatted version of `F` in mode `C`
(`'e` or `'E` = exponential, `'f` = fractional,
`'g` or `'G` = general with lower or upper case letters)
with maximum width `I` and precision `J`.

## srand      :  `I`  ->  
Sets the random integer seed to integer `I`.

## pred      :  `M`  ->  `N`
Numeric `N` is the predecessor of numeric `M`.

## succ      :  `M`  ->  `N`
Numeric `N` is the successor of numeric `M`.

## max      :  `N1 N2`  ->  `N`
`N` is the maximum of numeric values `N1` and `N2`.  Also supports float.

## min      :  `N1 N2`  ->  `N`
`N` is the minimum of numeric values `N1` and `N2`.  Also supports float.

## unstack      :  `[X Y ..]`  ->  `..Y X`
The list `[X Y ..]` becomes the new stack.

## cons      :  `X A`  ->  `B`
Aggregate `B` is `A` with a new member `X` (first member for sequences).

## swons      :  `A X`  ->  `B`
Aggregate `B` is `A` with a new member `X` (first member for sequences).

## first      :  `A`  ->  `F`
`F` is the first member of the non-empty aggregate `A`.

## rest      :  `A`  ->  `R`
`R` is the non-empty aggregate `A` with its first member removed.

## compare      :  `A B`  ->  `I`
`I` (=-1,0,+1) is the comparison of aggregates `A` and `B`.
The values correspond to the predicates <=, =, >=.

## at      :  `A I`  ->  `X`
`X` (= A[I]) is the member of `A` at position `I`.

## of      :  `I A`  ->  `X`
`X` (= A[I]) is the I-th member of aggregate `A`.

## size      :  `A`  ->  `I`
Integer `I` is the number of elements of aggregate `A`.

## opcase      :  `X [..[X Xs]..]`  ->  `[Xs]`
Indexing on type of `X`, returns the list `[Xs]`.

## case      :  `X [..[X Y]..]`  ->  `Y i`
Indexing on the value of `X`, execute the matching `Y`.

## uncons      :  `A`  ->  `F R`
`F` and `R` are the first and the rest of non-empty aggregate `A`.

## unswons      :  `A`  ->  `R F`
`R` and `F` are the rest and the first of non-empty aggregate `A`.

## drop      :  `A N`  ->  `B`
Aggregate B is the result of deleting the first `N` elements of `A`.

## take      :  `A N`  ->  `B`
Aggregate `B` is the result of retaining just the first `N` elements of `A`.

## concat      :  `S T`  ->  `U`
Sequence `U` is the concatenation of sequences `S` and `T`.

## enconcat      :  `X S T`  ->  `U`
Sequence U is the concatenation of sequences S and T
with X inserted between S and T (equivalent to `swapd cons concat`)

## name      :  `sym`  ->  `"sym"`
For operators and combinators, the string "sym" is the name of item sym,
for literals sym the result string is its type.

## intern      :  `"sym"`  -> `sym`
Pushes the item whose name is "sym".

## body      :  `U`  ->  `[P]`
Quotation [P] is the body of user-defined symbol U.

